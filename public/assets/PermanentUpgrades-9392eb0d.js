class l{constructor(){this.upgrades={damage:0,fireRate:0,speed:0,health:0,multiShot:0,piercing:0,explosive:0,lifesteal:0}}applyUpgrade(e){if(!e||!e.effect)return;const{type:s,value:t}=e.effect;return this.upgrades.hasOwnProperty(s)?(this.upgrades[s]+=t,!0):!1}getPlayerStats(e){return{damage:e.damage*(1+this.upgrades.damage),fireRate:e.fireRate*(1+this.upgrades.fireRate),speed:e.speed*(1+this.upgrades.speed),maxHealth:e.maxHealth+this.upgrades.health,multiShot:1+this.upgrades.multiShot,piercing:this.upgrades.piercing>0,explosive:this.upgrades.explosive>0,lifesteal:this.upgrades.lifesteal>0}}getBulletStats(e){const s={...e};return s.damage*=1+this.upgrades.damage,this.upgrades.piercing>0&&(s.piercing=!0,s.piercingCount=this.upgrades.piercing),this.upgrades.explosive>0&&(s.explosive=!0,s.explosionRadius=30+this.upgrades.explosive*10,s.explosionDamage=s.damage*.5),s}getMultiShotAngles(e){const s=1+this.upgrades.multiShot,t=[];if(s===1)t.push(e);else{const i=Math.PI/8,o=i*2/(s-1);for(let r=0;r<s;r++){const p=-i+o*r;t.push(e+p)}}return t}processLifesteal(e,s){if(this.upgrades.lifesteal>0){const t=Math.max(1,Math.floor(s*.1*this.upgrades.lifesteal));return e.heal(t),t}return 0}createExplosion(e,s,t,i){if(this.upgrades.explosive<=0)return[];const o=30+this.upgrades.explosive*10,r=this.upgrades.explosive*20,p=[];return t.forEach(a=>{if(a.type==="enemy"&&a.alive&&Math.sqrt(Math.pow(a.x-e,2)+Math.pow(a.y-s,2))<=o){const u=a.takeDamage(r);p.push({entity:a,destroyed:u})}}),i&&i.createExplosion(e,s),p}getUpgradeLevel(e){return this.upgrades[e]||0}getAllUpgrades(){return{...this.upgrades}}reset(){Object.keys(this.upgrades).forEach(e=>{this.upgrades[e]=0})}getDebugText(){return Object.entries(this.upgrades).filter(([s,t])=>t>0).map(([s,t])=>`${s}:${t}`).join(" ")||"No upgrades"}}export{l as PermanentUpgrades};
