var d=Object.defineProperty;var y=(h,t,i)=>t in h?d(h,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):h[t]=i;var r=(h,t,i)=>(y(h,typeof t!="symbol"?t+"":t,i),i);const e=class e{constructor(t=0,i=0){this.x=t,this.y=i,this.vx=0,this.vy=0,this.width=32,this.height=32,this.alive=!0,this.type="entity",this.id=e.nextId++,this.collisionRadius=16,this.rotation=0}update(t){this.x+=this.vx*t,this.y+=this.vy*t}render(t){t.save(),t.translate(this.x,this.y),t.rotate(this.rotation),t.fillStyle="#ffffff",t.fillRect(-this.width/2,-this.height/2,this.width,this.height),t.restore()}destroy(){this.alive=!1}getBounds(){return{left:this.x-this.width/2,right:this.x+this.width/2,top:this.y-this.height/2,bottom:this.y+this.height/2}}getCenter(){return{x:this.x,y:this.y}}distanceTo(t){const i=t.x-this.x,s=t.y-this.y;return Math.sqrt(i*i+s*s)}angleTo(t){return Math.atan2(t.y-this.y,t.x-this.x)}collidesWith(t){return!this.alive||!t.alive?!1:this.distanceTo(t)<this.collisionRadius+t.collisionRadius}constrainToArea(t,i,s){const a=this.x-t,n=this.y-i;if(Math.sqrt(a*a+n*n)>s){const o=Math.atan2(n,a);this.x=t+Math.cos(o)*s,this.y=i+Math.sin(o)*s}}reset(){this.x=0,this.y=0,this.vx=0,this.vy=0,this.alive=!0}};r(e,"nextId",0);let l=e;export{l as E};
